/* ============================================================================
 *  Dither.c: Dithering Functions.
 *
 *  Original author: `MooglyGuy`. Many thanks to: Ville Linde, `angrylion`,
 *  Shoutouts to: `olivieryuyu`, `marshallh`, `LaC`, `oman`, `pinchy`, `ziggy`,
 *  `FatCat` and other folks I forgot.
 *
 *  Vectorization, Cleanup by Tyler J. Stachecki.
 *
 *  This file is subject to the terms and conditions defined in
 *  file 'MAMELICENSE', which is part of this source code package.
 * ========================================================================= */
#include "Common.h"
#include "Core.h"
#include "Dither.h"

static void DitherComplete(int32_t *r, int32_t *g, int32_t *b, int32_t dither);
static void DitherNothing(int32_t *r, int32_t *g, int32_t *b, int32_t dither) {}

const DitherFunc DitherFuncLUT[2] = {
  DitherComplete,
  DitherNothing
};

/* value = (value > 247) ? 0xFF : (value & 0xF8) + 8; */
static const uint8_t DitherLUT[256] align(64) = {
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
  0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
  0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 
  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
  0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 
  0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 
  0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 
  0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 
  0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 
  0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 
  0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 
  0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 
  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
  0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
  0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 
  0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 
  0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 
  0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 
  0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 
  0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 
  0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 
  0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 
  0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 
  0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 
  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
  0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};

static void DitherComplete(int32_t *r, int32_t *g, int32_t *b, int32_t dither) {
  if ((*r & 7) > dither)
    *r = DitherLUT[*r];

  if (other_modes.rgb_dither_sel != 2) {
    if ((*g & 7) > dither)
      *g = DitherLUT[*g];

    if ((*b & 7) > dither)
      *b = DitherLUT[*b];
  }

  else {
    if ((*g & 7) > ((dither + 3) & 7))
      *g = DitherLUT[*g];

    if ((*b & 7) > ((dither + 5) & 7))
      *b = DitherLUT[*b];
  }
}

